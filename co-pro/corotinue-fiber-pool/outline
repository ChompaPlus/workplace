;hook:
对原始的api的同名封装，在调用这个api时，拦截对原始api的调用，去执行我们封装好的同名api

;考虑为什么使用协程，难道线程不能再系统阻塞的情况下进行切换么？
先理清楚二者的区别
| 特性         | 线程                        | 协程              |
| ------       | -----------------          | ---------------   |
| 切换由谁控制  | 操作系统调度器（抢占式）      | 用户程序控制（主动式）     |
| 切换成本      | 高（上下文、内核态切换）       | 极低（用户态栈切换）      |
| 阻塞行为       | 阻塞整个线程                | 不阻塞线程，只挂起当前协程   |
| 并发模型      | 多线程并发                   | 单线程内可并发多协程      |
| 栈大小        | 一般为 1MB+，无法大规模开线程  | 一般为几 KB，可创建数万协程 |

线程切换：保存cpu上下文、切换内核栈、改变调度队列、TLB/cache失效影响性能

    线程是由操作系统进行调度的（抢占式的工作方式），比如当线程调用read（）或connect（）等阻塞系统调用时，
他会阻塞整个线程，操作系统也不能立即知道什么时候恢复线程，并且恢复的开销也很大，如果我们使用单线程来处理多个
事件，串行执行方式还会发生阻塞的情况就会导致效率格外的低，那么考虑使用多线程或者线程池来实现并发性，那还是有限制的
因为线程的栈大小一般大于1mb，也无法大规模的开线程，此外切换线程的开销也很大，所以这时候就要考虑协程

'   从规模上来考虑，一个协程栈大小一般为几kb，所以可以大规模的开协程，并且切换不需要内核参与开销几乎为0，
    从工作方式上考虑，协程是完全由用户控制的，可以随意的切换，当系统调用阻塞时，他不会阻塞线程，只会把当前协程挂起，线程还是可以来调度其他协程继续执行任务，等到需要恢复的时候比如资源准备就绪，
再恢复协程的执行，所以看起来让我们的服务器没有阻塞的阶段，提高处理的效率。'


本项目的优势：
基于事件驱动+hookio+协程调度
非阻塞io封装
把read、write、connect等阻塞系统调用变成非阻塞的，通过epoll监听
单线程高并发
一个线程可以同时维护'看起来是并发'的io任务
使用线程池利用cpu多核资源
创建线程池，每一个线程都可以创建成百上千的协程，提高资源利用率
调度器统一管理

具体是如何实现让服务器看起来没有阻塞的阶段的？
使用hook拦截原始系统调用，然后按照我们定义的方式去执行，'尽可能让线程将事件花在有意义的地方'
要注意的是hook只改变了行为过程，不改变行为结果，因为调用方是不知道hook的细节的，如果结果与原本的不一致会造成困惑

没有hook的时候在一个线程上还是串行执行的，


在 UNIX/Linux 系统中：
IO = 对某个文件描述符（fd）进行数据的输入或输出操作。
这个 fd 可能对应的是：
套接字（socket）：最常见于网络通信
普通文件
管道（pipe）
设备文件（/dev/xxx）
标准输入/输出（stdin, stdout）



原来scheduler